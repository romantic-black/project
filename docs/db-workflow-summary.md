# 数据库核心流程快速总结

## 🎯 核心流程（一句话概括）

**CAN帧 → 解码 → 内存聚合 → 批量写入数据库 → 实时查询**

## 📊 数据流转图（简化版）

```
┌─────────────┐
│  CAN帧       │ 每100ms
└──────┬──────┘
       │
       ▼ decode
┌─────────────────┐
│ 信号值          │ VCU_VehSpeed = 45.5
└──────┬──────────┘
       │
       ▼ batchInsertSignalValue
┌────────────────────────────────────┐
│ 内存时间桶（聚合中）               │
│ ┌─────────────────┐               │
│ │ 1秒桶           │               │
│ │ min/max/avg/sum │               │
│ └─────────────────┘               │
│ ┌─────────────────┐               │
│ │ 10秒桶          │               │
│ │ min/max/avg/sum │               │
│ └─────────────────┘               │
└────────┬──────────────────────────┘
         │
         │ 达到批量阈值 OR 定时刷新
         ▼
┌────────────────────────────────────┐
│ 事务写入数据库                      │
│ INSERT INTO signals_agg_1s/10s    │
└────────┬───────────────────────────┘
         │
         ▼
┌────────────────────────────────────┐
│ 查询API                             │
│ - snapshot: 最新值                  │
│ - history: 历史趋势                 │
└────────────────────────────────────┘
```

## 🔑 关键概念

### 1. 时间桶聚合
- **目的**：减少数据量（100行/秒 → 1行/秒）
- **机制**：相同时间窗口内的多个值聚合成一条记录
- **统计**：min, max, avg, first, last

### 2. 双时间窗口
- **1秒窗口**：实时查询，细粒度历史
- **10秒窗口**：长期趋势，数据归档
- **选择**：根据查询时间范围自动选择合适表

### 3. 批量写入
- **内存缓存**：累积100个样本或等待5秒
- **事务保证**：原子性写入，要么全部成功要么全部失败
- **性能**：单次写入数百行，而不是逐行写入

## 📈 性能数据

| 指标 | 值 |
|------|-----|
| 原始数据 | 100行/秒（10信号×10次/秒） |
| 聚合后（1s） | 10行/秒（90%压缩） |
| 聚合后（10s） | 1行/秒（99%压缩） |
| 写入延迟 | < 5ms/批 |
| 查询延迟 | < 10ms（1秒范围） |

## 🛠️ 关键代码位置

| 功能 | 文件 | 关键方法 |
|------|------|---------|
| 插入数据 | `db/repo.ts` | `batchInsertSignalValue()` |
| 批量刷新 | `db/repo.ts` | `flush()` |
| 查询历史 | `db/repo.ts` | `queryHistory()` |
| 查询快照 | `db/repo.ts` | `getSnapshot()` |
| 表定义 | `db/schema.ts` | `signalsAgg1s`, `signalsAgg10s` |

## 🎬 实际运行示例

```typescript
// 1. 接收到CAN帧
canSource.onFrame(frame => {
  const msg = normalizeFrame(frame); // 解码
  
  // 2. 批量插入信号值
  for (const [signalName, value] of Object.entries(msg.values)) {
    dbRepo.batchInsertSignalValue(msg.timestamp, signalName, value);
  }
});

// 3. 自动触发flush（每100条或5秒）
// 4. 查询最新值
const snapshot = dbRepo.getSnapshot(['VCU_VehSpeed', 'VCU_BatSOC']);
// { VCU_VehSpeed: 45.5, VCU_BatSOC: 85.0 }

// 5. 查询历史
const history = dbRepo.queryHistory(
  ['VCU_VehSpeed'], 
  from, 
  to, 
  '1s'  // 或 '10s'
);
```

## ⚠️ 重要注意点

1. **数据不是实时写入**：内存缓存5秒或100条，存在延迟
2. **数据会丢失**：数据库损坏时自动重建，历史数据丢失
3. **1秒聚合可禁用**：低性能模式下只保留10秒聚合
4. **查询使用索引**：复合索引 (timestamp, signal_name) 加速查询

## 🔄 对比传统方案

| 方案 | 存储量 | 查询速度 | 实现复杂度 |
|------|--------|---------|-----------|
| **传统**：逐条记录 | 36万行/小时 | 慢（大表） | 简单 |
| **本方案**：时间桶聚合 | 3.6万行/小时 | 快（索引+小表） | 中等 |

**结论**：用稍高的复杂度换取10倍数据压缩和更快的查询

## 📚 扩展阅读

- 完整流程说明：[db-workflow.md](./db-workflow.md)
- 代码实现：[apps/server/src/db/repo.ts](../apps/server/src/db/repo.ts)
- 表结构定义：[apps/server/src/db/schema.ts](../apps/server/src/db/schema.ts)

