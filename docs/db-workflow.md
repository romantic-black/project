# 数据库架构与流程说明

## 概述

本系统采用 **聚合存储架构**，通过时间窗口聚合大幅减少数据量，同时保持查询性能。

## 核心设计理念

### 为什么使用聚合存储？

```
原始数据流：
CAN帧 -> 解码 -> 信号值 (100ms周期)
10条信号 × 10次/秒 = 100行/秒 = 36万行/小时 ❌ 数据量过大

聚合后：
10条信号 × 1秒窗口 = 10行/秒 = 3.6万行/小时 ✅ 数据量减少90%

双时间窗口设计：
- 1秒窗口：实时查询、近期历史（细粒度）
- 10秒窗口：长期趋势、数据归档（粗粒度，压缩率更高）
```

## 数据流程

### 1. 数据写入流程

```
┌─────────────────────────────────────────────────────────────────┐
│                     CAN帧数据输入                                │
│               (100ms周期，实时接收)                              │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│   normalizeFrame(frame)                                         │
│   - 解码CAN帧                                                     │
│   - 提取信号值                                                    │
│   - 健康检测                                                      │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│   dbRepo.batchInsertSignalValue(timestamp, signalName, value)   │
│   批量插入信号值到内存缓存                                        │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ├─────────────────────────────────────┐
                         ▼                                     ▼
            ┌──────────────────────────┐      ┌──────────────────────────┐
            │  1秒时间桶聚合             │      │  10秒时间桶聚合           │
            │  - 按秒对齐时间戳          │      │  - 按10秒对齐时间戳       │
            │  - 更新统计值：           │      │  - 更新统计值：           │
            │    * sum, count          │      │    * sum, count          │
            │    * min, max            │      │    * min, max            │
            │    * first, last         │      │    * first, last         │
            └──────────┬───────────────┘      └──────────┬───────────────┘
                       │                                 │
                       └────────────┬────────────────────┘
                                    │
                       ┌────────────▼────────────┐
                       │   pendingCount++        │
                       │   (累积待写入计数)       │
                       └────────────┬────────────┘
                                    │
                        ┌───────────┴───────────┐
                        │                       │
                        ▼                       ▼
        ┌─────────────────────────┐  ┌─────────────────────────┐
        │  批量触发条件1:          │  │  批量触发条件2:          │
        │  pendingCount >=         │  │  定时触发 (5秒)          │
        │   batchSize (100)        │  │                          │
        └──────────┬──────────────┘  └──────────┬───────────────┘
                   │                            │
                   └────────────┬───────────────┘
                                │
                                ▼
          ┌─────────────────────────────────────────────────┐
          │   flush() - 批量刷新到数据库                      │
          │   1. 收集所有ready的time bucket                  │
          │      (时间窗口已过期 >= 1000ms 或 >= 10000ms)     │
          │   2. 计算平均值: avg = sum / count               │
          │   3. 使用事务批量插入                            │
          │   4. 使用PreparedStatement提高性能               │
          └────────────────────┬────────────────────────────┘
                               │
                               ▼
          ┌─────────────────────────────────────────────────┐
          │   事务执行 (ACID保证)                            │
          │   - INSERT INTO signals_agg_1s                  │
          │   - INSERT INTO signals_agg_10s                 │
          │   - 原子提交                                      │
          └────────────────────┬────────────────────────────┘
                               │
                               ▼
          ┌─────────────────────────────────────────────────┐
          │   性能监控与日志                                  │
          │   - 记录flush耗时                                │
          │   - 记录插入行数                                 │
          │   - 更新传输监控统计                              │
          └─────────────────────────────────────────────────┘
```

### 2. 时间桶聚合原理

```typescript
// 示例：信号 VCU_VehSpeed 的数据流

时间戳(ms) | 原始值 | 1秒桶时间戳 | 10秒桶时间戳 | 操作
-----------|--------|-------------|--------------|-----
12345      | 45.5   | 12000       | 10000        | updateBucket
12456      | 45.8   | 12000       | 10000        | updateBucket
12678      | 46.2   | 12000       | 10000        | updateBucket
...
13123      | 47.1   | 13000       | 10000        | updateBucket (新1秒桶)
14156      | 48.5   | 14000       | 10000        | updateBucket (新1秒桶)
...
20000      | -      | -           | 10000        | FLUSH! (10秒窗口过期)

flush结果：
signals_agg_1s:
  - timestamp=12000, signal_name=VCU_VehSpeed, avg=45.8, max=46.2, min=45.5, ...
  - timestamp=13000, signal_name=VCU_VehSpeed, avg=46.5, max=47.1, min=45.8, ...
  - timestamp=14000, signal_name=VCU_VehSpeed, avg=47.8, max=48.5, min=47.1, ...

signals_agg_10s:
  - timestamp=10000, signal_name=VCU_VehSpeed, avg=46.3, max=48.5, min=45.5, ...
```

**关键点：**
- 时间戳对齐：`Math.floor(timestamp / 1000) * 1000` 确保同一秒内所有数据聚合到一个桶
- 延迟刷新：数据在内存中累积，等待时间窗口过期或达到批量大小才写入
- 增量更新：同个时间桶内的新数据会更新 min/max/sum/count，而不是多次插入

### 3. 数据查询流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    API请求                                       │
│              (GET /api/snapshot 或 /api/history)                 │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
        ┌────────────────────────────────────────┐
        │   根据查询类型选择表                     │
        │   - snapshot: signals_agg_1s          │
        │   - history: signals_agg_1s 或        │
        │              signals_agg_10s          │
        └────────────┬───────────────────────────┘
                     │
       ┌─────────────┴─────────────┐
       │                           │
       ▼                           ▼
┌─────────────┐          ┌─────────────────────┐
│ getSnapshot │          │  queryHistory       │
│             │          │                     │
│ 查询逻辑：   │          │  查询逻辑：          │
│ - 使用子查询 │          │  - WHERE 时间范围    │
│ - 获取每个   │          │  - WHERE 信号名列表  │
│   信号的     │          │  - ORDER BY         │
│   最新值     │          │  - 使用索引优化      │
└─────────────┘          └─────────────────────┘
       │                           │
       └─────────────┬─────────────┘
                     │
                     ▼
        ┌────────────────────────────┐
        │   使用PreparedStatement     │
        │   + 索引优化                │
        │   - 复合索引:               │
        │     (timestamp, signalName) │
        │   - 大幅提升查询性能         │
        └────────────┬───────────────┘
                     │
                     ▼
        ┌────────────────────────────┐
        │   返回格式化数据            │
        │   {                         │
        │     "signal1": 45.5,        │
        │     "signal2": 85.0         │
        │   }                         │
        └────────────────────────────┘
```

### 4. 数据库维护流程

```
定时任务 (每小时)
    │
    ▼
┌─────────────────────────────────────┐
│   cleanupTTL(days=7)                │
│   - 删除7天前的数据                  │
│   - 保持数据库大小可控                │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   使用PreparedStatement批量删除       │
│   - DELETE FROM frames_raw           │
│   - DELETE FROM signals_agg_1s       │
│   - DELETE FROM signals_agg_10s      │
│   - DELETE FROM events_alarm         │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   10%概率执行 VACUUM                 │
│   - 碎片整理                         │
│   - 回收空间                         │
│   - 优化数据库性能                    │
└─────────────────────────────────────┘
```

## 性能优化策略

### 1. 批量写入

**问题：** 每次CAN帧都写数据库会极慢

**解决：** 
- 内存中累积100个样本才写一次
- 使用事务批量插入
- 单次写入可插入数百行数据

### 2. PreparedStatement

**好处：**
- SQL编译后缓存，重用查询计划
- 防止SQL注入
- 性能提升 10-20%

```typescript
// 编译一次，执行多次
const stmt = db.prepare('INSERT INTO signals_agg_1s VALUES (?, ?, ?, ?, ?, ?, ?)');
for (const entry of buckets) {
  stmt.run(entry.timestamp, entry.signal, entry.min, ...); // 快速执行
}
```

### 3. 时间桶聚合

**数据压缩率：**
- 100ms周期信号，10次/秒
- 1秒窗口：10个值 -> 1行（压缩率 90%）
- 10秒窗口：100个值 -> 1行（压缩率 99%）

### 4. 索引优化

```sql
-- 最常用查询模式
SELECT * FROM signals_agg_1s 
WHERE timestamp >= ? AND timestamp <= ? 
  AND signal_name IN (?, ?, ...);

-- 优化：复合索引 (timestamp, signal_name)
CREATE INDEX idx_composite ON signals_agg_1s(timestamp, signal_name);
```

### 5. 数据库配置

```typescript
db.pragma('journal_mode = WAL');     // 写前日志，提高并发性能
db.pragma('synchronous = NORMAL');   // 平衡安全性和性能
db.pragma('cache_size = -64000');    // 64MB缓存
```

### 6. 性能监控

```typescript
transportMonitor.recordDbFlush(size, successCount, errorCount, duration);
```

监控指标：
- flush耗时
- 插入成功率
- 缓冲区大小
- 实际延迟

## 故障恢复

### 数据库损坏处理

```
检测到损坏
    │
    ▼
┌─────────────────────────────────────┐
│   1. 备份损坏数据库                  │
│      .db.corrupted.<timestamp>      │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   2. 清理WAL和SHM文件                │
│      .db-wal, .db-shm               │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   3. 重建数据库                      │
│      - 初始化表结构                  │
│      - 初始化索引                    │
│      - 初始化PreparedStatement       │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   4. 继续运行（从空数据库开始）        │
│      - 不影响服务可用性               │
│      - 只丢失历史数据                  │
└─────────────────────────────────────┘
```

**注意：** 数据丢失但服务不中断，适合实时监控场景

## 表结构对比

| 表名 | 用途 | 数据粒度 | 保留时间 | 索引 |
|------|------|---------|---------|------|
| `frames_raw` | 原始帧（未使用） | 每帧 | 7天 | - |
| `signals_agg_1s` | 实时查询、近期历史 | 1秒 | 7天 | timestamp, signal, composite |
| `signals_agg_10s` | 长期趋势、归档 | 10秒 | 7天 | timestamp, signal, composite |
| `events_alarm` | 告警历史 | 每事件 | 7天 | timestamp |

## 查询场景示例

### 场景1：实时仪表盘

```typescript
// 获取信号最新值
GET /api/snapshot?signals=VCU_VehSpeed,VCU_BatSOC

// SQL
SELECT signal_name, last_value
FROM signals_agg_1s s1
WHERE signal_name IN ('VCU_VehSpeed', 'VCU_BatSOC')
  AND timestamp = (
    SELECT MAX(timestamp) 
    FROM signals_agg_1s s2 
    WHERE s2.signal_name = s1.signal_name
  )
```

### 场景2：历史趋势图

```typescript
// 查询过去10分钟的数据，1秒精度
GET /api/history?signals=VCU_VehSpeed&from=2024-01-01T00:00:00Z&to=2024-01-01T00:10:00Z&step=1s

// SQL
SELECT timestamp, signal_name, last_value, max_value, min_value, avg_value
FROM signals_agg_1s
WHERE timestamp >= ? AND timestamp <= ? 
  AND signal_name = 'VCU_VehSpeed'
ORDER BY timestamp ASC
```

### 场景3：长期数据分析

```typescript
// 查询过去1小时的数据，10秒精度（数据量更小）
GET /api/history?signals=VCU_VehSpeed&from=...&to=...&step=10s

// SQL
SELECT timestamp, signal_name, last_value, max_value, min_value, avg_value
FROM signals_agg_10s  -- 使用10秒表
WHERE timestamp >= ? AND timestamp <= ? 
ORDER BY timestamp ASC
```

## 性能指标

在正常负载下（100ms周期，10条信号）：

- **写入延迟**: 批处理 ~5ms/批，单条 < 0.1ms（内存）
- **查询延迟**: 1秒范围 < 10ms，1小时范围 < 50ms
- **数据压缩**: 1秒窗口 90%，10秒窗口 99%
- **存储占用**: ~10MB/小时（10条信号）

## 总结

本数据库架构通过以下设计实现了高性能和高可靠性：

✅ **聚合存储** - 大幅减少数据量  
✅ **批量写入** - 提高写入性能  
✅ **PreparedStatement** - 查询性能优化  
✅ **复合索引** - 加速范围查询  
✅ **自动维护** - TTL清理和VACUUM  
✅ **故障恢复** - 数据库损坏自动重建  
✅ **双窗口** - 灵活应对不同查询需求

